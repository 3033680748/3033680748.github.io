---
layout: post
title: "RISCV汇编生成器开发(一)---读代码"
date:   2024-10-26
tags: [编译技术, 后端, RISCV]
comments: true
author: 久菜合子
---

参考代码：同方向上一届二等奖项目https://gitlab.eduxiji.net/educg-group-26173-2487151/T202410614202951-722/-/tree/main

ps: 后端涉及的代码在 'backend' 文件夹里
### RISCV汇编生成时上下文结构（RISCVLoweringContext）
##### &emsp;&emsp;&emsp;首先，无论是参考的上一届的代码还是本次比赛的目标成果，都会使用```类LLVM IR```作为中间表示。所以，相较于纯文本的IR，由中端向后端提供```类LLVM数据结构```，显然可以省去一些分析工作。<br>
##### &emsp;&emsp;&emsp;LLVM有关于优化的```Value, User, Usee等```数据结构，在后端中不再考虑，转而使用```Module, Function, BasicBlock, Intruction```的数据结构，这些结构描述了一个或多个文件中，代码的组织层次。
![Screenshot 2024-10-26 113915.png](https://www.helloimg.com/i/2024/10/26/671c647598604.png)
##### &emsp;&emsp;&emsp;有关于如何使用这些结构，参考源码有关的申明
```c++
// ./include/backend/RISCVLowering.hpp
class RISCVModuleLowering:BackEndPass<Module>{
    RISCVLoweringContext ctx;
    void LowerGlobalArgument(Module*); 
    public:
    bool run(Module*);
};

class RISCVFunctionLowering:BackEndPass<Function>{
    RISCVLoweringContext& ctx;
    RISCVAsmPrinter*& asmprinter;
    public:
    bool run(Function*);
    RISCVFunctionLowering(RISCVLoweringContext& ctx, RISCVAsmPrinter*& asmprinter):ctx(ctx),asmprinter(asmprinter){};
};
```
##### &emsp;&emsp;&emsp;```ctx```代表context, 也就是上下文信息, 是本文分析数据结构的起点, 定义在RISCVContext.hpp中<br>
```c++
class RISCVLoweringContext{
    std::map<Value*,RISCVMOperand*> val2mop; // LLVM Value类 到 机器操作数的映射
    using MFuncPtr=std::unique_ptr<RISCVFunction>;
    std::vector<MFuncPtr> functions;    // 机器函数向量组
    RISCVFunction* cur_func;        // 当前处理机器函数
    RISCVBasicBlock* cur_mbb;   // 当前机器BasicBlock
    RISCVMOperand* Create(Value*); // 当LLVM Value* 不在 val2mop中时，为它创建一个机器操作数
    public:  
    //
    void operator()(RISCVMIR*); // 处理中间表示
    void operator()(RISCVBasicBlock*); // 处理BasicBlock
    void operator()(RISCVFunction*); // 处理Function
    void insert_val2mop(Value*, RISCVMOperand*); // 插入map
    void change_mapping(RISCVMOperand*, RISCVMOperand*); // 改变映射关系
    RISCVMOperand* mapping(Value*); // 进行映射
    VirRegister* createVReg(RISCVType); // 创建虚拟寄存器
    std::vector<MFuncPtr>& GetFunctions(); // 返回函数调用链表
    RISCVFunction*& GetCurFunction(); // 当前Function
    RISCVBasicBlock*& GetCurBasicBlock(); // 当前BasicBlock
    Value* GetValue(RISCVMOperand*); // 当前Value
    void print(); // 打印
};
```
##### &emsp;&emsp;&emsp;上述的```机器```的含义指的是汇编指令一级，而不是更底层的机器码。<br>&emsp;&emsp;&emsp;可以看到```RISCVLoweringContext```，做了很多由LLVM IR映射到汇编指令的工作。<br>
##### &emsp;&emsp;&emsp;现在看看最基本的，如何由一个Value*，创建一个RISCVMOperand*
```c++
RISCVMOperand* RISCVLoweringContext::Create(Value* val){
    if(auto inst=dynamic_cast<User*>(val)){
        if(auto alloca=dynamic_cast<AllocaInst*>(inst)){
            auto& frameobjs=cur_func->GetFrame()->GetFrameObjs();
            frameobjs.emplace_back(new RISCVFrameObject(inst));
            auto subtype=dynamic_cast<HasSubType*>(inst->GetType())->GetSubType();
            if(dynamic_cast<ArrayType*>(subtype)){
                // 是个数组，加载首地址到一个虚拟寄存器
                return cur_func->GetUsedGlobalMapping(frameobjs.back().get());
            }
            return frameobjs.back().get(); 
        }
        else if(auto store=dynamic_cast<StoreInst*>(inst))
            assert(0&&"Can't be Used");
        else if(auto cond=dynamic_cast<CondInst*>(inst))
            assert(0&&"Can't be Used");
        else if(auto uncond=dynamic_cast<UnCondInst*>(inst))
            assert(0&&"Can't be Used");
        else if(auto ret=dynamic_cast<RetInst*>(inst))
            assert(0&&"Can't be Used");
        // else if(auto call=dynamic_cast<CallInst*>(inst))
            // assert("Can't be Used");
        else{
            return createVReg(RISCVTyper(inst->GetType()));
        }
    }
    else if(auto bb=dynamic_cast<BasicBlock*>(val))
        return RISCVBasicBlock::CreateRISCVBasicBlock();
    else if(val->isConst()){
        // change bool const to int const
        if(auto boolval=val->as<ConstIRBoolean>()){
            auto imm=boolval->GetVal();
            return Imm::GetImm(ConstIRInt::GetNewConstant(imm));
        }
        return Imm::GetImm(val->as<ConstantData>());
    }
    else if(auto func=dynamic_cast<Function*>(val))
        return new RISCVFunction(func);
    else if(auto buildin=dynamic_cast<BuildInFunction*>(val)){
        return new RISCVFunction(buildin);
    }
    assert(0&&"Can't be Used");
}
```
##### &emsp;&emsp;&emsp;程序按照Value\*的继承方式组织不同的分支，User\*、BasicBlock\*、Function\*，注意包含对常量的转换、处理内置函数，并且在处理User\*时使用了createVReg方法。<br>
##### &emsp;&emsp;&emsp;其他方法都比较简单，主要是在管理当前的IR语境，这里再重点关注一下```creatVReg```方法，涉及寄存器分配。
```c++
VirRegister* RISCVLoweringContext::createVReg(RISCVType type){
    return new VirRegister(type);
}
```
### 寄存器分配（初步）
##### &emsp;&emsp;&emsp;转到RISCVRegister.hpp
```c++
class Register:public RISCVMOperand{
    protected:
    std::string rname;
    public:
    Register(RISCVType _tp):RISCVMOperand(_tp){};
    Register(RISCVType _tp,std::string_view _name):RISCVMOperand(_tp),rname(_name){};
    virtual bool isPhysical()=0;
    virtual std::string GetName()=0;
};
```
##### &emsp;&emsp;&emsp;首先是最基础的Register类，继承自RISCVMOperand，寄存器也是asm中操作数的一种形式。<br>&emsp;&emsp;&emsp;可以关注到，成员变量中专门有一个用于指示是否为物理寄存器的bool变量。<br>
##### &emsp;&emsp;&emsp;接着看物理寄存器类PhyRegister
```c++
class PhyRegister:public Register{
    public:
    enum PhyReg{
        zero,ra,sp,gp,tp,t0,t1,t2,s0,s1,
        a0,a1,a2,a3,a4,a5,a6,a7,
        s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,
        t3,t4,t5,t6,
        ft0,ft1,ft2,ft3,ft4,ft5,ft6,ft7,
        fs0,fs1,fa0,fa1,
        fa2,fa3,fa4,fa5,fa6,fa7,
        fs2,fs3,fs4,fs5,fs6,fs7,fs8,fs9,fs10,fs11,
        ft8,ft9,ft10,ft11,
        
        _NULL,
        
        begin_normal_reg=zero,
        end_normal_reg=t6,
        begin_float_reg=ft0,
        end_float_reg=ft11,

        x0=zero,x1=ra,x2=sp,x3=gp,x4=tp,x5=t0,x6=t1,x7=t2,x8=s0,x9=s1,
        x10=a0,x11=a1,x12=a2,x13=a3,x14=a4,x15=a5,x16=a6,x17=a7,
        x18=s2,x19=s3,x20=s4,x21=s5,x22=s6,x23=s7,x24=s8,x25=s9,x26=s10,x27=s11,
        x28=t3,x29=t4,x30=t5,x31=t6
    }regenum;
    protected:
    PhyRegister(PhyReg);
    public:
    static PhyRegister* GetPhyReg(PhyReg);
    PhyReg Getregenum(){return regenum;};
    void print();
    std::string GetName();
    bool isPhysical()final{return true;};
    /// @return (1<<regenum), if valid 
    inline uint64_t GetPhyRegMask(){ // 获取寄存器掩码
        assert(regenum<64&&"incorrect regnum");
        return ((uint64_t)1)<<regenum;
    };
    inline bool isCallerSaved(){
        if(regenum==PhyReg::ra)return true;
        if(regenum>=PhyReg::t0&&regenum<=PhyReg::t2)return true;
        if(regenum>=PhyReg::a0&&regenum<=PhyReg::a7)return true;
        if(regenum>=PhyReg::t3&&regenum<=PhyReg::t6)return true;
        if(regenum>=PhyReg::ft0&&regenum<=PhyReg::ft7)return true;
        if(regenum>=PhyReg::fa0&&regenum<=PhyReg::fa7)return true;
        if(regenum>=PhyReg::ft8&&regenum<=PhyReg::ft11)return true;
        return false;
    };
    inline bool isCalleeSaved(){
        // if(regenum==sp)return true;
        if(regenum==s1)return true;
        // if(regenum>=PhyReg::s0&&regenum<=PhyReg::s1)return true;
        if(regenum>=PhyReg::s2&&regenum<=PhyReg::s11)return true;
        if(regenum>=PhyReg::fs0&&regenum<=PhyReg::fs1)return true;
        if(regenum>=PhyReg::fs2&&regenum<=PhyReg::fs11)return true;
        return false;
    };
};
```
##### &emsp;&emsp;&emsp;这个类中比较关键的是，枚举了物理寄存器，并且判断是调用者（Caller）或者被调者寄存器（Callee）。借用X64中的寄存器距离，rdi,rsi,rcx,rdx,r8,r9等是调用者保存的寄存器，rsp,rbp等是被调用者保存的寄存器。
```c++
class VirRegister:public Register{
    int counter;
    uint32_t penalty_spill;
    uint32_t penalty_reload;

  public:
    inline uint32_t GetPenaltySpill() { return penalty_spill; };
    inline uint32_t GetPenaltyReload() { return penalty_reload; };
    VirRegister(RISCVType, uint32_t = 6, uint32_t = 6);
    std::string GetName();
    void print()final;
    bool isPhysical()final{return false;};
};
```
##### &emsp;&emsp;&emsp;关键在于两个惩罚值，操作数分配到内存的惩罚以及从内存中取操作数的惩罚。这一类VirRegister涉及变量活跃性的判断，理论上可以将中端的判断结果传到后端，但该项目没有这样做，而是在后端单独实现了一个变量活跃性的算法，可能是因为课程要求先拉通编译流程，然后再完善中端部分。
##### &emsp;&emsp;&emsp;然后是专门用于存放地址（LoadAddress）的寄存器，其中RISCVType是asm中的数据类型。
```c++
class LARegister:public Register{
    Register* vreg=nullptr;
    public:
    enum LAReg {
        hi,lo
    } regnum;
    LARegister(RISCVType, std::string);
    LARegister(RISCVType, std::string, LAReg);
    LARegister(RISCVType, std::string, Register*);
    void print()final;
    Register*& GetVreg();
    void SetReg(PhyRegister*&);
    std::string GetName(){return rname;}
    bool isPhysical()final{return true;};
};
```
#####  &emsp;&emsp;&emsp;在最后是一个存放寄存器链的类，也是和变量活跃性有关。
```c++
class RegisterList {
    private:
    std::vector<PhyRegister*> reglist_int;
    std::vector<PhyRegister*> reglist_float;
    std::vector<PhyRegister*> reglist_caller;
    std::vector<PhyRegister*> reglist_test;

    RegisterList();
    RegisterList(const RegisterList&) = delete;
    RegisterList& operator=(const RegisterList&) = delete;
    public:
    static RegisterList& GetPhyRegList();
    std::vector<PhyRegister*>& GetReglistInt();
    std::vector<PhyRegister*>& GetReglistFloat();
    std::vector<PhyRegister*>& GetReglistTest();
    std::vector<PhyRegister*>& GetReglistCaller();
};
```
### 变量活跃性分析（待完善）


### 两个run()方法过程梳理
##### &emsp;&emsp;&emsp;在RICSVLowering.hpp中（生成asm的入口），```Module*和Fucntion*```是中端提供的类LLVM数据结构，由类LLVM的Value多次继承得到（在CFG.hpp中），下面的```Function*```可以由```Module```的类方法得到。<br>&emsp;&emsp;&emsp;两类lower各有一个```run```方法。<br>
```c++
class Function:public Value,public mylist<Function,BasicBlock>;
class Module:public SymbolTable;
```
##### &emsp;&emsp;&emsp;现在关注一下Module的```run```方法，
```c++
extern std::string asmoutput_path;
RISCVAsmPrinter *asmprinter = nullptr;
void RISCVModuleLowering::LowerGlobalArgument(Module *m)
{
    // need file name
    asmprinter = new RISCVAsmPrinter(asmoutput_path, m, ctx); // 输出文件路径，IR的LLVM结构，上下文(context)
}

bool RISCVModuleLowering::run(Module *m)
{
    LowerGlobalArgument(m); // 设置asmprinter
    RISCVFunctionLowering funclower(ctx, asmprinter);
    auto &funcS = m->GetFuncTion(); // auto = std::vector<std::unique_ptr<Function>>
    for (auto &func : funcS)
    {
        if (funclower.run(func.get()))
        {
            func->print();  // 
            std::cerr << "FUNC Lowering failed\n";
        }
    }

    asmprinter->printAsm();
    return false;
}
```
##### &emsp;&emsp;&emsp;逻辑比较简单，从Module类中取出Function的链表，然后调用FunctionLower::run()逐个操作。其中```func->print()```，是CFG.hpp中定义的一个Function类的方法，是打印该Function的LLVM IR，应该是方便出错时Debug定位。如果没错就asmprinter打印。<br>
##### &emsp;&emsp;&emsp;接下来关注FunctionLower::run()方法, 以下是全部内容。
```c++
bool RISCVFunctionLowering::run(Function *m)
{
    if(m->get_tag() == Function::BuildIn) {
        return false;
    }

    BuildInFunctionTransform buildin;
    buildin.run(m);

    auto mfunc = ctx.mapping(m)->as<RISCVFunction>();
    ctx(mfunc);

    RISCVISel isel(ctx, asmprinter);
    isel.run(m);

    PhiElimination phi(ctx);
    phi.run(m);

    asmprinter->SetTextSegment(new textSegment(ctx));
    asmprinter->GetData()->GenerateTempvarList(ctx);
    // // asmprinter->GetData()->LegalizeGloablVar(ctx);

    // Backend DCE before RA
    bool modified = true;
    while (modified)
    {
        modified = false;
        BackendDCE dcebefore(mfunc, ctx);
        modified |= dcebefore.RunImpl();
    }

    // Pre_RA_Scheduler pre_scheduler;
    // pre_scheduler.ScheduleOnFunction(ctx);

    // Register Allocation
    RegAllocImpl regalloc(mfunc, ctx);
    regalloc.RunGCpass();
    std::cout << std::flush;
    for (auto block : *(ctx.GetCurFunction()))
    {
        for (auto it = block->begin(); it != block->end();)
        {
            auto inst = *it;
            ++it;
            if (inst->GetOpcode() == RISCVMIR::RISCVISA::MarkDead)
                delete inst;
        }
    }
    modified = true;
    // Backend DCE after RA
    while (modified)
    {
        modified = false;
        BackendDCE dceafter(ctx.GetCurFunction(), ctx);
        modified |= dceafter.RunImpl();
    }
    
    // Pre_RA_Scheduler pre_scheduler;
    // pre_sclheduer.ScheduleOnFunction(ctx);
    
    // Post_RA_Scheduler post_scheduler;
    // post_scheduler.ScheduleOnFunction(ctx);

    // Generate Frame of current Function
    // And generate the head and tail of frame here
    PostRACalleeSavedLegalizer callee_saved_legalizer;
    callee_saved_legalizer.run(ctx.GetCurFunction());

    auto& frame = ctx.GetCurFunction()->GetFrame();
    frame->GenerateFrame();
    frame->GenerateFrameHead();
    frame->GenerateFrameTail();

    // legal.run_afterRA();
    Legalize legal(ctx);
    legal.run();

    auto dbd=DeleteDeadBlock();
    dbd.run(ctx.GetCurFunction());

    auto layout=CodeLayout();
    layout.run(mfunc);

    return false;
}
```
##### &emsp;&emsp;&emsp;根据设计文档.pdf，这个run()方法中做了很多事，包括处理库函数、指令选择入口、寄存器分配入口、函数栈帧生成入口、指令合法化入口。<br>现在逐行看一下源代码。<br>
##### &emsp;&emsp;&emsp;首先是如何处理库函数，这个库函数是比赛规定的库函数，比如```getarray()、putarray()```，而不是c语言标准库函数
```C++
    /// @brief 相关定义，在CFG.hpp中
    ///     enum Tag{
    ///     Normal,
    ///     UnrollBody,
    ///     LoopBody,
    ///     ParallelBody,
    ///     BuildIn,
    ///     };

    if(m->get_tag() == Function::BuildIn) {
        return false;
    } 
```
##### &emsp;&emsp;&emsp;```return false```就是什么也没干，体现在asm中就是直接的```call xxx```。<br>
##### &emsp;&emsp;&emsp;然后下一句（跳过Note），将BuildIn的函数转换为正确的形式
```c++
    BuildInFunctionTransform buildin;
    buildin.run(m);
```
##### &emsp;&emsp;&emsp;看一下```BuildInFunctionTransform```的定义与实现，以及其中使用的```Traval::BuildInTransform```方法
```c++
class BuildInFunctionTransform:public BackEndPass<Function>{
    public:
    bool run(Function*) override;
};
bool BuildInFunctionTransform::run(Function* func){
    for(auto bb:*func)  // 遍历Function中所有的BasicBlock
        for(auto it=bb->begin();it!=bb->end();++it){    // 遍历BasicBlock中所有的Instruction
            auto inst=*it;
            if(auto call=dynamic_cast<CallInst*>(inst)) 
                inst=Trival::BuildInTransform(call); // 如果是Call指令，使用这个方法转换。
            it=mylist<BasicBlock,User>::iterator(inst);
        }
    return true;
}

/// @note 下面是Trival相关的定义
namespace Trival{
    bool check_builtin(std::string id);
    User* GenerateCallInst(std::string id,std::vector<Operand> args);
    /// @brief transform any buildin fuction so that it can be assembled and linked correctly
    /// @return return the new callinst 
    CallInst* BuildInTransform(CallInst*);
};

bool Trival::check_builtin(std::string id){ // 查表检查是否为buildIn函数
    if(id=="getint")return true;
    if(id=="getfloat")return true;
    if(id=="getch")return true;
    if(id=="getarray")return true;
    if(id=="getfarray")return true;        
    if(id=="putint")return true;
    if(id=="putch")return true;
    if(id=="putarray")return true;
    if(id=="putfloat")return true;
    if(id=="putfarray")return true;
    if(id=="starttime")return true;
    if(id=="stoptime")return true;
    if(id=="putf")return true;
    if(id=="llvm.memcpy.p0.p0.i32")return true;
    return false;
}

User* Trival::GenerateCallInst(std::string id,std::vector<Operand> args){
    // 略
}

CallInst* Trival::BuildInTransform(CallInst* inst){
    if(!check_builtin(inst->GetOperand(0)->GetName())){
        return inst; // 检查
    }
    if(inst->GetOperand(0)->GetName()=="llvm.memcpy.p0.p0.i32"){
        auto dst=inst->GetOperand(1);
        auto src=inst->GetOperand(2);
        auto size=inst->GetOperand(3);
        auto args=std::vector<Operand>();
        args.push_back(dst);
        args.push_back(src);
        args.push_back(size);
        auto tmp=new CallInst(BuildInFunction::GetBuildInFunction("memcpy@plt"),args,"");
        inst->FullReplace(tmp);
        delete inst;
        return tmp;
    }
    return inst;
    // 如果是 "llvm.memcpy.p0.p0.i32", 就转换为 "memcpy@plt"
    // 看起来很复杂的机制，实际上只做了这一个东西
}
```
##### &emsp;&emsp;&emsp;总的来说就是递归地检查所有Intruction中的```CallInst```，然后将名为"llvm.memcpy.p0.p0.i32"的换为"memcpy@plt", 方便ld链接, 实际上这一部分就匹配的函数名而言可以继续拓展。

##### &emsp;&emsp;&emsp;将当前的Function参数，经过ctx的映射后加入到ctx的翻译队列
```c++
    auto mfunc = ctx.mapping(m)->as<RISCVFunction>();
    ctx(mfunc);
```
##### &emsp;&emsp;&emsp;下一句
```c++
    RISCVISel isel(ctx, asmprinter);
    isel.run(m);
```
##### &emsp;&emsp;&emsp;进入RISCVISel的定义，RISCV指令选择器
```c++
void LowerFormalArguments(Function* func, RISCVLoweringContext& ctx);
// 转换函数参数
class RISCVISel:public BackEndPass<Function>{
    RISCVLoweringContext& ctx;
    RISCVAsmPrinter*& asmprinter;
    std::vector<LoopInfo*>DeleteLoop;
    RISCVMIR* Builder(RISCVMIR::RISCVISA,User*);  // 返回 RISCV的汇编IR,方便后端优化
    RISCVMIR* Builder_withoutDef(RISCVMIR::RISCVISA,User*);
    RISCVMIR* Builder(RISCVMIR::RISCVISA,std::initializer_list<RISCVMOperand*>);
    RISCVMIR* Builder_withoutDef(RISCVMIR::RISCVISA _isa,std::initializer_list<RISCVMOperand*> list);

    void LowerCallInstParallel(CallInst*);
    void LowerCallInstCacheLookUp(CallInst*);
    
    // return the virreg which handles the condition
    // will register to the mapping automatically
    void condition_helper(BinaryInst*);

    void InstLowering(User*);   // 针对每种Instruction的Lowering
    void InstLowering(AllocaInst*);
    void InstLowering(StoreInst*);
    void InstLowering(LoadInst*);
    void InstLowering(FPTSI*);
    void InstLowering(SITFP*);
    void InstLowering(UnCondInst*);
    void InstLowering(CondInst*);
    void InstLowering(BinaryInst*);
    //
    void InstLowering(GetElementPtrInst*);
    //
    void InstLowering(PhiInst*);
    //
    void InstLowering(CallInst*);
    void InstLowering(RetInst*);

    void InstLowering(ZextInst*);
    void InstLowering(SextInst*);
    void InstLowering(TruncInst*);
    void InstLowering(SelectInst*);

    void InstLowering(MinInst*);
    void InstLowering(MaxInst*);
 
    RISCVMOperand* Li_Intimm(ConstIRInt* Intconst);
    public:
    RISCVISel(RISCVLoweringContext&, RISCVAsmPrinter*&);
    bool run(Function*);
};
```
##### &emsp;&emsp;&emsp;现在主要关注最后的run方法，具体实现方法比较复杂，
```
1.入口块处理：如果函数有参数，则创建一个RISCV基本块作为入口块，并进行参数降低。
2.基本块遍历：使用支配树对函数的基本块进行深度优先遍历，并对每个基本块中的指令进行降低。
3.分支概率处理：获取分支概率信息，并根据这些信息调整终止指令的概率。
```
##### &emsp;&emsp;&emsp;回到Lowering::run中，下一部分是Phi函数消除，这里不展开
```c++
    PhiElimination phi(ctx);
    phi.run(m);
```
##### &emsp;&emsp;&emsp;设置asmprinter
```c++
    asmprinter->SetTextSegment(new textSegment(ctx));
    asmprinter->GetData()->GenerateTempvarList(ctx);
```
##### &emsp;&emsp;&emsp;死代码消除(DCE)
```c++
    bool modified = true;
    while (modified)
    {
        modified = false;
        BackendDCE dcebefore(mfunc, ctx);
        modified |= dcebefore.RunImpl();
    }
```
##### &emsp;&emsp;&emsp;寄存器分配(RA)
```c++
    RegAllocImpl regalloc(mfunc, ctx);
    regalloc.RunGCpass();
    std::cout << std::flush;
    for (auto block : *(ctx.GetCurFunction()))
    {
        for (auto it = block->begin(); it != block->end();)
        {
            auto inst = *it;
            ++it;
            if (inst->GetOpcode() == RISCVMIR::RISCVISA::MarkDead)
                delete inst;
        }
    }
```
#####  &emsp;&emsp;&emsp;再次DCE
```c++
    modified = true;
    // Backend DCE after RA
    while (modified)
    {
        modified = false;
        BackendDCE dceafter(ctx.GetCurFunction(), ctx);
        modified |= dceafter.RunImpl();
    }
```
##### &emsp;&emsp;&emsp;callee的存储合法化
```c++
    PostRACalleeSavedLegalizer callee_saved_legalizer;
    callee_saved_legalizer.run(ctx.GetCurFunction());

    auto& frame = ctx.GetCurFunction()->GetFrame();
    frame->GenerateFrame();
    frame->GenerateFrameHead();
    frame->GenerateFrameTail();

    // legal.run_afterRA();
    Legalize legal(ctx);
    legal.run();
```
##### &emsp;&emsp;&emsp;删除CFG中无效的Block
```c++
    auto dbd=DeleteDeadBlock();
    dbd.run(ctx.GetCurFunction());
```
##### &emsp;&emsp;&emsp;可读化
```c++
    auto layout=CodeLayout();
    layout.run(mfunc);
```