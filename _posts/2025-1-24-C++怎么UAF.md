---
layout: post
title: "[水贴]C++应该怎么UAF"
date:   2025-1-24
tags: [pwn, 水]
comments: true
author: 久菜合子
---

ps: 讨论场景为c++17

## 智能指针
##### &emsp;&emsp;&emsp;智能指针是C++的常用特性之一, 用于解决C语言以及早期C++中的内存分配和释放过于复杂, 或者内存泄露的问题.<br>&emsp;&emsp;&emsp;一般使用的智能指针有```std::unique_ptr, std::shared_ptr, std::weak_ptr```, ```std::weak_ptr```可以看作是```std::shared_ptr```在特定情况下的补充. 需要```#include <memory>```.<br>&emsp;&emsp;&emsp;然而, 即使有智能指针, 也不能高枕无忧, 因为内存问题是所有人都要面对的, 除非你是高贵的数据分析科学家, 或者你使用语言(yu'an)神Rust<br>&emsp;&emsp;&emsp;下面简单列一下本人发现的可以对智能指针UAF的方法.

## shared_ptr<>
###  &emsp;内存回收方式<br>
##### &emsp;&emsp;&emsp;```shared_ptr```是比较常用的智能指针, 一块堆内存可以被多个若干个```shared_ptr```指向, 这块内存会记录被指向的数目(引用计数shared_count), 当引用归零时, 内存被释放. 表面上看是这样的.<br>&emsp;&emsp;&emsp;实际上```std::make_shared<>```分配的内存有两个计数器, ```shared_count和weak_count```(各4字节), 当然是为了配合```weak_ptr```使用<br>
##### &emsp;&emsp;&emsp;那么```shared_ptr```在内存中是什么样的的组织方式, 下面一个demo
```c++
#include <iostream>
#include <memory>

int main(){
    {
        std::shared_ptr<size_t> ptr1 = std::make_shared<size_t>(0x12345678);
        std::shared_ptr<size_t> ptr2 = ptr1;
    }
    return 0;
}
```
![Screenshot 2025-01-24 231137.png](https://www.helloimg.com/i/2025/01/24/6793ad0a07ea8.png)
##### &emsp;&emsp;&emsp;上图是```ptr2 = ptr1```之后的栈空间
##### &emsp;&emsp;&emsp;可以看到其实比较简单, ```shared_ptr```对象本身是 ```地址(指针) + 一个虚表指针```
![Screenshot 2025-01-24 231631.png](https://www.helloimg.com/i/2025/01/24/6793ae2a45c2a.png)
##### &emsp;&emsp;&emsp;上述指针(即```.get()```获取的裸指针)指向的一个```chunk```的中间部分, 对象的位置. 前面的是```0x555555557cc8```虚表地址, 和```0x1```weak_count, ```0x2```shared_count(use count).<br>&emsp;&emsp;&emsp;值得一提的是weak_count返回的是0, 但实际上在内存中存的是1
##### &emsp;&emsp;&emsp;作用域结束之后, 分别对两个```std::shared_ptr```对象进行析构<br>
##### &emsp;&emsp;&emsp;第一个析构之后, 堆肯定是没有释放的, 但是use count变成了```0x1```<br>
##### &emsp;&emsp;&emsp;然后追踪一下第二个析构
![Screenshot 2025-01-24 213734.png](https://www.helloimg.com/i/2025/01/24/6793b05b77e6a.png)
##### &emsp;&emsp;&emsp;注意下面的调用栈, 现在在```_M_release()```中<br>
##### &emsp;&emsp;&emsp;```movabs```这一句, 0x100000001直接硬编码在指令里, 看来是有bear而来<br>
##### &emsp;&emsp;&emsp;```cmp```, ```rax```里是堆块中```use count + weak count```的那一个字长的拷贝. 这里就是比较此时是不是两个```count```都只剩1了, 也就是该堆块只有当前正在析构的指针还在引用, 如果是的话, ZF标志位为1<br>
##### &emsp;&emsp;&emsp;```sete al```, 当equal(ZF为1)时, al被设置为1, 反之为0<br>
##### &emsp;&emsp;&emsp;```test al, al```, 经典按位与用来判断是不是0, 结果不是0, ZF变成0
##### &emsp;&emsp;&emsp;```je ...```, 此时不跳转, 进入下面的堆块释放环节.
##### &emsp;&emsp;&emsp;释放的环节调用了两个方法, ```_M_dispose```, 和```_M_destroy```, 但是在这之前, ```use count```和```weak count```被清零了, 如下图
![Screenshot 2025-01-24 214047.png](https://www.helloimg.com/i/2025/01/24/6793b4c72b804.png)
##### &emsp;&emsp;&emsp;然后分别```call```了```_M_dispose```, 和```_M_destroy```
![Screenshot 2025-01-24 221428.png](https://www.helloimg.com/i/2025/01/24/6793b574dd8dd.png)
![Screenshot 2025-01-24 215026.png](https://www.helloimg.com/i/2025/01/24/6793b5a67c6ff.png)
##### &emsp;&emsp;&emsp;在```_M_destory```中, 在```~__allocator_ptr```, 之后堆块释放. 更细节的调用没再追踪了
![Screenshot 2025-01-24 221129.png](https://www.helloimg.com/i/2025/01/24/6793b6565a060.png)
##### &emsp;&emsp;&emsp;如果两个```count```不是1, 会进入下面的分支
![Screenshot 2025-01-24 220024.png](https://www.helloimg.com/i/2025/01/24/6793b6d9c1d7e.png)
### &emsp;shared_ptr的UAF
##### &emsp;&emsp;&emsp;根据上面的分析, 得知两点<br>
##### &emsp;&emsp;&emsp;第一, 必须要让```use count```和```weak count```都是1, 才能触发堆块释放的操作<br>
##### &emsp;&emsp;&emsp;第二, 想要让一个堆块释放, 应该先进入一个```shared_ptr```的析构函数, 毕竟没人会在用了智能指针之后还手动delete.<br>
##### &emsp;&emsp;&emsp;如此, 一个简单的UAF思路产生了, 利用程序漏洞篡改两个```count```都是1, 然后触发析构, 如果此时还有别的```shared_ptr```没析构, 那么就成功UAF了, 不过这个UAF没法劫持虚表以及再次改两个```count```.
##### &emsp;&emsp;&emsp;看另一个demo
```c++
#include <iostream>
#include <memory>

int main(){
    
    std::shared_ptr<size_t> ptr = std::make_shared<size_t>(0x12345678);
    
    {
        std::shared_ptr<size_t> ptr1 = ptr;
        // change use count: 2 -> 1
        unsigned int *use_count = (unsigned int *)((unsigned long long)(ptr1.get()) - 8);
        *use_count = 1;
        // 生命周期结束, ptr1析构, 同时触发ptr和ptr1指向的堆块free
    }

    std::shared_ptr<size_t> ptr_new = std::make_shared<size_t>(114514);

    *ptr = 1919810; // UAF

    std::cout<< *ptr_new <<std::endl;
     
    return 0;
}

```
##### &emsp;&emsp;&emsp;UAF大成功, 没用的知识又增加了
```
$ g++ test.cpp -g -o test
$ ./test 
1919810
```

## weak_ptr
### &emsp;内存回收方式
##### &emsp;&emsp;&emsp;首先了解一下```weak_ptr```的使用场景, 就是为了避免``shared_ptr```之间的循环引用.
##### &emsp;&emsp;&emsp;先看一个没有循环引用的demo, 结构体wrapper有一个成员ptr.
```c++
#include <iostream>
#include <memory>

struct wrapper
{
    std::shared_ptr<wrapper> ptr;
};

int main(){
    
    {
        ///@note wrapprx 应该叫做 wrapperx_ptr 才符合语义, 但是图都截了...
        std::shared_ptr<wrapper> wrapper1 = std::make_shared<wrapper>();
        std::shared_ptr<wrapper> wrapper2 = std::make_shared<wrapper>();
        std::shared_ptr<wrapper> wrapper3 = std::make_shared<wrapper>();
        wrapper1->ptr = wrapper2;
        wrapper2->ptr = wrapper3;
        wrapper3->ptr = nullptr;
    }

    return 0;
}
```
![Screenshot 2025-01-25 232012.png](https://www.helloimg.com/i/2025/01/25/679500556e25c.png)
##### &emsp;&emsp;&emsp;如图, 在wrapper1析构之后, 对应的内存没有free. 事实上, 在wrapper3之后, 三个chunk才会一起释放. 但这个过程中, 三个wrapper指向的内存的引用计数在正确地减少.
##### &emsp;&emsp;&emsp;注意作用域结束时, 析构的顺序是构造的顺序是相反的, v12是赋值是产生的copy, 可以不管
![Screenshot 2025-01-25 234952.png](https://www.helloimg.com/i/2025/01/25/67950718340db.png)
##### &emsp;&emsp;&emsp;```std::shared_ptr<wrapper>::~shared_ptr(wrapper1);```析构```wrapper1```时, 析构了```wrapper1->ptr```, ```wrapper1->ptr```指针析构时又其指向的对象(wrapper2), ```wrapper2```析构时, 需要析构```wrapper2->ptr```, 析构```wrapper2->ptr```是析构了指向的对象```*wrapper3```<br>
##### &emsp;&emsp;&emsp;```*wrapper3```的chunk释放之后, 调用栈回溯, 逐个又free其他chunk<br>
##### &emsp;&emsp;&emsp;如果说话的方式简单点, 就是析构智能指针就会析构所指向的对象, 析构所指向的对象就会该对象使用的智能指针.<br>
##### &emsp;&emsp;&emsp;在这个过程中, 三块内存保存的use_count

|析构状态|chunk1|chunk2|chunk3|
|:---:|:---:|:---:|:---:|
|没析构|1|2|2|
|wrapper3析构|1|2|1|
|wrapper2析构|1|1|1|
|wrapper1析构|free|free|free|

##### &emsp;&emsp;&emsp;进入正题, 有循环引用的demo
```c++
#include <iostream>
#include <memory>

struct wrapper
{
    std::shared_ptr<wrapper> ptr;
};

int main(){
    
    {
        std::shared_ptr<wrapper> wrapper1 = std::make_shared<wrapper>();
        std::shared_ptr<wrapper> wrapper2 = std::make_shared<wrapper>();
        wrapper2->ptr = wrapper1;
        wrapper1->ptr = wrapper2; // 构成循环引用
    }

    return 0;
}
```
![Screenshot 2025-01-25 224711.png](https://www.helloimg.com/i/2025/01/25/6794f93b7560c.png)
##### &emsp;&emsp;&emsp;如图, 当作用域结束之后, 两块wrapper的内存都没有释放<br>
##### &emsp;&emsp;&emsp;简单概括一下, 智能指针```wrapper1```析构时, 会析构```wrapper```对象(存在第一个chunk里), 然后析构```ptr```成员, 析构```wrapper```(存在第二个chunk里), 然后又```ptr```成员, 最后回去析构存在第一个chunk里的```wrapper```, 成功转了个圈<br>
##### &emsp;&emsp;&emsp;析构函数应该有什么检查机制(可能是检查地址), 因为这个循环递归地析构函数调用并不会卡死程序, 但是确实会让引用计数无法正确减少, 一直都是2, 对应的两个chunk永远无法free, 变成僵尸内存.

# To be continued...

